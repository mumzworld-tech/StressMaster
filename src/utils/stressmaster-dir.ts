/**
 * Centralized StressMaster Directory Utility
 *
 * All StressMaster-generated files and directories are organized under:
 *   .stressmaster/
 *     ├── config/       - Configuration files (ai-config.json)
 *     ├── cache/        - Cache files (parse-cache.json)
 *     ├── k6-scripts/   - Generated K6 scripts
 *     ├── exports/      - Exported test results
 *     ├── results/      - Test results
 *     └── templates/    - Test templates
 *
 * This keeps all StressMaster artifacts in one place, making it easy to:
 * - Clean up (just delete .stressmaster/)
 * - Add to .gitignore
 * - Understand what files StressMaster created
 */

import * as path from "path";
import * as fs from "fs";

/**
 * Get the base StressMaster directory path
 * @param rootDirectory - Root directory (default: process.cwd())
 */
export function getStressMasterDir(
  rootDirectory: string = process.cwd()
): string {
  return path.join(rootDirectory, ".stressmaster");
}

/**
 * Get the config directory path
 */
export function getConfigDir(rootDirectory: string = process.cwd()): string {
  return path.join(getStressMasterDir(rootDirectory), "config");
}

/**
 * Get the AI config file path
 */
export function getAIConfigPath(rootDirectory: string = process.cwd()): string {
  return path.join(getConfigDir(rootDirectory), "ai-config.json");
}

/**
 * Get the cache directory path
 */
export function getCacheDir(rootDirectory: string = process.cwd()): string {
  return path.join(getStressMasterDir(rootDirectory), "cache");
}

/**
 * Get the parse cache file path
 */
export function getParseCachePath(
  rootDirectory: string = process.cwd()
): string {
  return path.join(getCacheDir(rootDirectory), "parse-cache.json");
}

/**
 * Get the K6 scripts directory path
 */
export function getK6ScriptsDir(rootDirectory: string = process.cwd()): string {
  return path.join(getStressMasterDir(rootDirectory), "k6-scripts");
}

/**
 * Get the exports directory path
 */
export function getExportsDir(rootDirectory: string = process.cwd()): string {
  return path.join(getStressMasterDir(rootDirectory), "exports");
}

/**
 * Get the results directory path
 */
export function getResultsDir(rootDirectory: string = process.cwd()): string {
  return path.join(getStressMasterDir(rootDirectory), "results");
}

/**
 * Get the templates directory path
 */
export function getTemplatesDir(rootDirectory: string = process.cwd()): string {
  return path.join(getStressMasterDir(rootDirectory), "templates");
}

/**
 * Ensure the StressMaster directory structure exists and create .gitignore
 */
export function ensureStressMasterDirs(
  rootDirectory: string = process.cwd()
): void {
  const stressMasterDir = getStressMasterDir(rootDirectory);
  const dirs = [
    stressMasterDir,
    getConfigDir(rootDirectory),
    getCacheDir(rootDirectory),
    getK6ScriptsDir(rootDirectory),
    getExportsDir(rootDirectory),
    getResultsDir(rootDirectory),
    getTemplatesDir(rootDirectory),
  ];

  // Create all directories
  for (const dir of dirs) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  // Create .gitignore inside .stressmaster/ to ensure nothing is tracked by git
  // This is a double-layer protection - even if .stressmaster/ isn't in root .gitignore,
  // the directory itself will ignore all its contents
  const gitignorePath = path.join(stressMasterDir, ".gitignore");
  if (!fs.existsSync(gitignorePath)) {
    const gitignoreContent = `# StressMaster Generated Files
# This directory contains all files generated by StressMaster
# Everything in this directory should be ignored by git

# Ignore everything
*

# But allow .gitignore itself
!.gitignore
`;
    fs.writeFileSync(gitignorePath, gitignoreContent, "utf-8");
  }

  // Also ensure .stressmaster/ is in the project's root .gitignore
  ensureProjectGitIgnore(rootDirectory);
}

/**
 * Ensure .stressmaster/ is added to the project's root .gitignore
 * This ensures StressMaster files never show up as git changes
 */
function ensureProjectGitIgnore(rootDirectory: string = process.cwd()): void {
  const gitignorePath = path.join(rootDirectory, ".gitignore");
  const stressMasterIgnore = ".stressmaster/";

  try {
    // Check if .gitignore exists
    if (!fs.existsSync(gitignorePath)) {
      // Create .gitignore with StressMaster entry
      const content = `# StressMaster Generated Files\n${stressMasterIgnore}\n`;
      fs.writeFileSync(gitignorePath, content, "utf-8");
      return;
    }

    // Read existing .gitignore
    const content = fs.readFileSync(gitignorePath, "utf-8");

    // Check if .stressmaster/ is already in .gitignore (exact match or as part of a comment)
    const lines = content.split("\n");
    const alreadyIgnored = lines.some((line) => {
      const trimmed = line.trim();
      return (
        trimmed === stressMasterIgnore ||
        trimmed === `.stressmaster` ||
        trimmed.includes(stressMasterIgnore) ||
        trimmed.includes(`.stressmaster`)
      );
    });

    if (alreadyIgnored) {
      // Already present, nothing to do
      return;
    }

    // Add .stressmaster/ to .gitignore
    const newContent =
      content.trim() +
      "\n\n# StressMaster Generated Files\n" +
      stressMasterIgnore +
      "\n";
    fs.writeFileSync(gitignorePath, newContent, "utf-8");
  } catch (error) {
    // Silently fail - .gitignore update is not critical
    // The .gitignore inside .stressmaster/ provides protection anyway
  }
}
